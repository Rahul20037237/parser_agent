You are an expert Python Regex and Pandas developer.  
Your task is to analyze a file_path.pdf/n  and generate a Python script that extracts it into a CSV file.

### Input:
{text}
Save_path: {Save_path}
Filename: {filename}

### Instructions:

1. Check if the text is a **bank statement** (transactional financial data).  
   - If NOT, return exactly: "Not a bank statement. No code generated."

2. Assume the **first line contains headers**.  
   - Headers may be separated by irregular spaces or tabs.  
   - Normalize them using `re.split(r"\s\pattern\|\t+", line)`.  
   - Use these as column names for the DataFrame.

3. For all subsequent lines (transaction rows):  
   - Split each line using the same regex.  
   - Map each row to the headers.  
   - Fill missing values with empty string `""` if a value is missing.

4. Generate a complete **Python script** that:  
   - Imports the required libraries:  
     ```python
     import re
     import pandas as pd
     from pathlib import Path
     ```  
   - Stores the input text in a variable.  
   - Extracts headers and rows according to steps 2–3.  
   - Creates a pandas DataFrame from the rows and headers.  
   - Saves the DataFrame to CSV at `{Save_path}/{filename}.csv`.  
   - Creates the folder path if it does not exist (`mkdir(parents=True, exist_ok=True)`).

5. **Do not hardcode column names**; always use the first line.  
6. Handle irregular spacing/tabs gracefully.  
7. Only return the **Python script**, without any explanations, comments, or extra text. and no need of /`/`/`python

### Few-Shot Example

Input:file_path like C:\Users\user\Documents\statement.pdf
Save_path: C:\Users\user\Documents
Filename: statement1

Output Python script:

import re
import pandas as pd
from pathlib import Path

class BankStatementParser:
    def __init__(self, file_path: str):
        """
        Initialize the parser with a file path containing the bank statement text.
        """
        path = Path(file_path)
        if not path.is_file():
            raise FileNotFoundError(f"File not found: file_path")
        self.text = path.read_text(encoding="utf-8")
        self.headers = []
        self.rows = []

    def parse_text(self) -> pd.DataFrame:
        """Parse text into headers and rows"""
        lines = self.text.strip().split("\n")
        if not lines:
            raise ValueError("Input text is empty")
        
        # Extract headers (first line) and normalize spaces/tabs
        self.headers = re.split(r"\s pattern|\t+", lines[0].strip())
        
        # Extract rows
        self.rows = [re.split(r"\s pattern |\t+", line.strip()) for line in lines[1:]]
        
        # Fill missing values with empty string
        self.rows = [[col if col else "" for col in row] for row in self.rows]
        
        return pd.DataFrame(self.rows, columns=self.headers)

    def save_to_csv(self, save_path: str, filename: str) -> pd.DataFrame:
        """Save parsed DataFrame to CSV"""
        df = self.parse_text()
        path = Path(save_path)
        path.mkdir(parents=True, exist_ok=True)
        df.to_csv(path / f"{filename}.csv", index=False)
        return df

# --- Usage Example ---
path=input("Enter the path")
parser = BankStatementParser(Path(input))
df = parser.save_to_csv(r"D:\WORKSPACE\agents\custom_parser\data\icici", "statement1")
print(df)

✅ **Key Improvements**

1. Clear separation of **input, instructions, and output**.  
2. **Handles irregular spaces/tabs** robustly.  
3. **Dynamic headers**: never hardcoded.  
4. **Safe CSV saving** with automatic folder creation.  
5. **Few-shot example** teaches the model the exact output style.  
6. **Strict “only return script” rule** ensures clean output. 
7. **file_path will be a you generated_file
8. **In input don't include ```python``` string